- 组件间通信基本原则

  - 不能在子组件中直接修改父组件的状态数据
  - 数据在哪, 更新数据的行为(函数)就定义在哪

- 组件通信方式

  - props/$emit

    ```vue
    <Child :title="title" @changeTitle="handler" />
     
     methods: {
      handler: function (newTitle) {
        this.title = newTitle
      }
    }
    //子组件
    this.$emit('changeTitle', newTitle)
    ```

    > 1. 父组件传递数据时类似在标签中写了一个属性，如果是传递的数据是data中的自然是要在传递属性前加v-bind,如果传递的是一个已知的固定值呢
    >    1. 字符串是静态的可直接传入无需在属性前加v-bind
    >    2. 数字，布尔，对象，数组，因为这些是js表达式而不是字符串，所以即使这些传递的是静态的也需要加v-bind，把数据放到data中引用
    > 2. 如果prop传到子组件中的数据是一个对象的话，要注意传递的是一个对象引用，虽然父子组件看似是分离的但最后都是在同一对象下
    >    1. 如果prop传到子组件的值只是作为初始值使用，且在父组件中不会变化则赋值到data中使用
    >    2. 如果传到子组件的prop的数据在父组件会被改变的，放到计算属性中监听变化使用。因为如果传递的是个对象的话，只改变对象的某个属性子组件中是不会响应式更新的，如果子组件需要在数据变化时响应式更新那只能放到computed中或者用watch深拷贝deep:true才能监听到变化
    >    3. 当然如果你又需要在子组件中通过prop传递数据的变化做些操作，那么写在computed中会报警告，因为计算属性中不推荐有任何数据的改变,只进行计算。如果你非要进行数据的操作那么可以把监听写在watch（注意deep深拷贝）或者使用computed的get和set
    >    4. 但问题又来了，如果你传进来的是个对象，同时你又需要在子组件中操作传进来的这个数据，那么在父组件中的这个数据也会改变，**因为你传递的只是个引用， 即使你把prop的数据复制到data中也是一样的**，无论如何赋值都是引用的赋值，你只能对对象做深拷贝创建一个副本才能继续操作，你可以用JSON的方法先转化字符串在转成对象
    >    5. 所以在父子传递数据时要先考虑好数据要如何使用，否则你会遇到很多问题或子组件中修改了父组件中的数据，这是很隐蔽并且很危险的

  - 父组件传递函数(数据在哪,操作在哪),可以一层一层传，子组件直接调用

  - provide - inject （注入的不是响应式的，需要配合计算属性达到）

    ```javascript
    export default {
      //方式一
      provide: {
        message: 'hello!'
      }
    	//方式二
    	provide() {
        // 使用函数的形式，可以访问到 `this`
        return {
          message: this.message
        }
      }
    }
    
    export default {
      inject: ['message'],
      created() {
        console.log(this.message) // injected value
      },
    	data() {
        return {
          // 基于注入值的初始数据
          fullMessage: this.message
        }
      }
    }
    
    export default {
      inject: {
        /* 本地属性名 */ localMessage: {
          from: /* 注入来源名 */ 'message'
        }
      }
    }
    
    export default {
      // 当声明注入的默认值时
      // 必须使用对象形式
      inject: {
        message: {
          from: 'message', // 当与原注入名同名时，这个属性是可选的
          default: 'default value'
        },
        user: {
          // 对于非基础类型数据，如果创建开销比较大，或是需要确保每个组件实例
          // 需要独立数据的，请使用工厂函数
          default: () => ({ name: 'John' })
        }
      }
    }
    
    //可响应example
    provide() {
      this.theme = Vue.observable({
        color: "blue"
      });
      return {
        theme: this.theme
      };
    }
    
    //可响应example
    import { computed } from 'vue'
    
    export default {
      data() {
        return {
          message: 'hello!'
        }
      },
      provide() {
        return {
          // 显式提供一个计算属性
          message: computed(() => this.message)
        }
      }
    }
    ```
    
  - event bus(\$emit / \$on)
  
    ```javascript
    //bus.js
    import Vue from 'vue'
    export default new Vue
    ```
  
    ```javascript
    import Bus from './bus.js'
    export default {
    	methods: {
    		bus() {
    			Bus.$emit('EVENT_NAME', payLoad)
    		},
    	},
    }
    ```
  
    ```javascript
    import Bus from './bus.js'
    export default {
    	mounted() {
    		Bus.$on('EVENT_NAME', function (payLoad) {})
    	},
    }
    ```
  
  - $attrs(inheritAttrs)、\$listeners
  
  - \$parent、$root、\$children？
  
  - \$refs
  
    > 父组件需要子组件的一个数据但子组件并不知道或者说没有能力在父组件想要的时候给父组件，那么这个时候就要用ref
    >
    > 1. 父组件在标签中定义ref属性，在js中直接调用this.$refs.xxx就是调用整个子组件，子组件的所有内容都能通过ref去调用，当然我们并不推荐因为这会使数据看起来非常混乱
    > 2. 所以我们可以在子组件中定义一种专供父组件调用的函数，比如我们在这个函数中返回子组件data中某个数据,当父组件想要获取这个数据就直接主动调用ref执行这个函数获取这个数据,这样能适应很大一部分场景，逻辑也更清晰一点
    > 3. 父向子传递数据也可以用ref，有次需要在一个父组件中大量调用同一个子组件，而每次调用传递的prop数据都不同，并且传递数据会根据之后操作变化，这样我需要在data中定义大量相关数据并改变它，可以直接用ref调用子组件函数直接把数据以参数的形式传给子组件，逻辑一下子清晰了
    > 4. 如果调用基础组件可以在父组件中调用ref执行基础组件中暴露的各种功能接口，比如显示，消失等
  
  - Vuex
  
    ```javascript
    // index.js
    import Vue from 'vue';
    import Tpl from './index.vue';
    import store from './store';
    
    new Vue({
      store,
      render: h => h(Tpl),
    }).$mount('#app');
    
    
    // store
    import Vue from 'vue';
    import Vuex from 'vuex';
    
    Vue.use(Vuex);
    
    const store = new Vuex.Store({
      state: {
        count: 1
      },
      mutations: {
        increment(state) {
          state.count++;
        },
        reduce(state) {
          state.count--;
        }
      },
      actions: {
        actIncrement({ commit }) {
          setTimeout(() => {
            commit('increment');
          })
        },
        actReduce({ commit }) {
          setTimeout(() => {
            commit('reduce');
          })
        }
      },
      getters: {
        doubleCount: state => state.count*2
      }
    });
    
    export default store;
    
    // vue文件
    <template>
      <div class="container">
        <p>我的count：{{count}}</p>
        <p>doubleCount:{{doubleCount}}</p>
        <button @click="this.actIncrement">增加</button>
        <button @click="this.actReduce">减少</button>
      </div>
    </template>
    
    <script>
    import { mapGetters, mapActions, mapState } from "vuex";
    
    export default {
      name: "demo",
      data: function() {
        return {};
      },
      components: {},
      props: {},
      computed: {
        ...mapState(["count"]),
        ...mapGetters(["doubleCount"])
      },
      methods: {
        ...mapActions(["actIncrement", "actReduce"])
      }
    };
    </script>
    ```
  
    
  
  - ### Summary
  
    - 父子通信：props / \$emit，​\$emit / ​\$on（EventBus），Vuex，\$attrs / \$listeners，provide/inject，\$parent / \$children＆\$refs
    - 兄弟通信：\$emit / \$on（EventBus），Vuex
    - 隔代（跨级）通信：\$emit / \$on（EventBus），Vuex，provide / inject，\$attrs / \$listeners
