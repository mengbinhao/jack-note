### 复杂度分析
- 事后统计法
    1. 测试结果非常依赖测试环境
    2. 测试结果受数据规模的影响很大
我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法

- 大O复杂度表示法
  - 所有代码的执行时间`T(n)`与每行代码的执行次数`n`成正比
  - `T(n) = O(f(n))`  T(n)表示代码执行的时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为这是一个公式，所以用f(n)来表示。公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比

当`n`很大时，你可以把它想象成10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大`O`表示法表示以下两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n<sup>2</sup>)

```java
//(2n+2)*unit_time -> T(n) = O(2n+2) -> T(n) = O(n)
 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

```java
//(2*n*n + 2n +3)unit_time -> T(n) = O(2*n*n + 2n +3) -> T(n) = O(n*n)
 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```
#### 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度(**总的时间复杂度等于量级最大的那段代码的时间复杂度**)
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

#### 几种常见时间复杂度实例分析
- 多项式量级(除了下面2个)
- 非多项式量级(O(2n) 和 O(n!))
![](../images/algorithm_2.png)

1. O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)
2. O(logn)、O(nlogn)
3. O(m + n)、O(m * n)

#### 空间复杂度分析
表示算法的存储空间与数据规模之间的增长关系

我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup> )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到

#### 最好情况时间复杂度
#### 最坏情况时间复杂度
#### 平均情况时间复杂度(加权平均时间复杂度、期望时间复杂度)
#### 均摊时间复杂度
均摊时间复杂度就是一种特殊的平均时间复杂度